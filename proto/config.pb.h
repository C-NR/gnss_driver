// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config.proto

#ifndef PROTOBUF_config_2eproto__INCLUDED
#define PROTOBUF_config_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace gnss_driver {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_config_2eproto();
void protobuf_AssignDesc_config_2eproto();
void protobuf_ShutdownFile_config_2eproto();

class Stream;
class Stream_Serial;
class Stream_Tcp;
class Stream_Udp;
class Stream_Ntrip;
class NovatelConfig;
class UbloxConfig;
class Config;

enum Stream_Format {
  Stream_Format_UNKNOWN = 0,
  Stream_Format_NMEA = 1,
  Stream_Format_RTCM_V2 = 2,
  Stream_Format_RTCM_V3 = 3,
  Stream_Format_NOVATEL_TEXT = 10,
  Stream_Format_NOVATEL_BINARY = 11,
  Stream_Format_UBLOX_TEXT = 20,
  Stream_Format_UBLOX_BINARY = 21
};
bool Stream_Format_IsValid(int value);
const Stream_Format Stream_Format_Format_MIN = Stream_Format_UNKNOWN;
const Stream_Format Stream_Format_Format_MAX = Stream_Format_UBLOX_BINARY;
const int Stream_Format_Format_ARRAYSIZE = Stream_Format_Format_MAX + 1;

const ::google::protobuf::EnumDescriptor* Stream_Format_descriptor();
inline const ::std::string& Stream_Format_Name(Stream_Format value) {
  return ::google::protobuf::internal::NameOfEnum(
    Stream_Format_descriptor(), value);
}
inline bool Stream_Format_Parse(
    const ::std::string& name, Stream_Format* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Stream_Format>(
    Stream_Format_descriptor(), name, value);
}
enum Config_RtkSolutionType {
  Config_RtkSolutionType_RTK_RECEIVER_SOLUTION = 1,
  Config_RtkSolutionType_RTK_SOFTWARE_SOLUTION = 2
};
bool Config_RtkSolutionType_IsValid(int value);
const Config_RtkSolutionType Config_RtkSolutionType_RtkSolutionType_MIN = Config_RtkSolutionType_RTK_RECEIVER_SOLUTION;
const Config_RtkSolutionType Config_RtkSolutionType_RtkSolutionType_MAX = Config_RtkSolutionType_RTK_SOFTWARE_SOLUTION;
const int Config_RtkSolutionType_RtkSolutionType_ARRAYSIZE = Config_RtkSolutionType_RtkSolutionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Config_RtkSolutionType_descriptor();
inline const ::std::string& Config_RtkSolutionType_Name(Config_RtkSolutionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Config_RtkSolutionType_descriptor(), value);
}
inline bool Config_RtkSolutionType_Parse(
    const ::std::string& name, Config_RtkSolutionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Config_RtkSolutionType>(
    Config_RtkSolutionType_descriptor(), name, value);
}
// ===================================================================

class Stream_Serial : public ::google::protobuf::Message {
 public:
  Stream_Serial();
  virtual ~Stream_Serial();

  Stream_Serial(const Stream_Serial& from);

  inline Stream_Serial& operator=(const Stream_Serial& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream_Serial& default_instance();

  void Swap(Stream_Serial* other);

  // implements Message ----------------------------------------------

  Stream_Serial* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stream_Serial& from);
  void MergeFrom(const Stream_Serial& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes device = 1;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 1;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const void* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // optional int32 baud_rate = 2 [default = 9600];
  inline bool has_baud_rate() const;
  inline void clear_baud_rate();
  static const int kBaudRateFieldNumber = 2;
  inline ::google::protobuf::int32 baud_rate() const;
  inline void set_baud_rate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gnss_driver.pb.Stream.Serial)
 private:
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_baud_rate();
  inline void clear_has_baud_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* device_;
  ::google::protobuf::int32 baud_rate_;
  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static Stream_Serial* default_instance_;
};
// -------------------------------------------------------------------

class Stream_Tcp : public ::google::protobuf::Message {
 public:
  Stream_Tcp();
  virtual ~Stream_Tcp();

  Stream_Tcp(const Stream_Tcp& from);

  inline Stream_Tcp& operator=(const Stream_Tcp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream_Tcp& default_instance();

  void Swap(Stream_Tcp* other);

  // implements Message ----------------------------------------------

  Stream_Tcp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stream_Tcp& from);
  void MergeFrom(const Stream_Tcp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional int32 port = 2 [default = 3001];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gnss_driver.pb.Stream.Tcp)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* address_;
  ::google::protobuf::int32 port_;
  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static Stream_Tcp* default_instance_;
};
// -------------------------------------------------------------------

class Stream_Udp : public ::google::protobuf::Message {
 public:
  Stream_Udp();
  virtual ~Stream_Udp();

  Stream_Udp(const Stream_Udp& from);

  inline Stream_Udp& operator=(const Stream_Udp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream_Udp& default_instance();

  void Swap(Stream_Udp* other);

  // implements Message ----------------------------------------------

  Stream_Udp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stream_Udp& from);
  void MergeFrom(const Stream_Udp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional int32 port = 2 [default = 3001];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gnss_driver.pb.Stream.Udp)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* address_;
  ::google::protobuf::int32 port_;
  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static Stream_Udp* default_instance_;
};
// -------------------------------------------------------------------

class Stream_Ntrip : public ::google::protobuf::Message {
 public:
  Stream_Ntrip();
  virtual ~Stream_Ntrip();

  Stream_Ntrip(const Stream_Ntrip& from);

  inline Stream_Ntrip& operator=(const Stream_Ntrip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream_Ntrip& default_instance();

  void Swap(Stream_Ntrip* other);

  // implements Message ----------------------------------------------

  Stream_Ntrip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stream_Ntrip& from);
  void MergeFrom(const Stream_Ntrip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const void* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional int32 port = 2 [default = 2101];
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional bytes mount_point = 3;
  inline bool has_mount_point() const;
  inline void clear_mount_point();
  static const int kMountPointFieldNumber = 3;
  inline const ::std::string& mount_point() const;
  inline void set_mount_point(const ::std::string& value);
  inline void set_mount_point(const char* value);
  inline void set_mount_point(const void* value, size_t size);
  inline ::std::string* mutable_mount_point();
  inline ::std::string* release_mount_point();
  inline void set_allocated_mount_point(::std::string* mount_point);

  // optional bytes user = 4;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 4;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const void* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional bytes password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const void* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional uint32 timeout_s = 6 [default = 30];
  inline bool has_timeout_s() const;
  inline void clear_timeout_s();
  static const int kTimeoutSFieldNumber = 6;
  inline ::google::protobuf::uint32 timeout_s() const;
  inline void set_timeout_s(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:gnss_driver.pb.Stream.Ntrip)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_mount_point();
  inline void clear_has_mount_point();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_timeout_s();
  inline void clear_has_timeout_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* address_;
  ::std::string* mount_point_;
  ::std::string* user_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::uint32 timeout_s_;
  ::std::string* password_;
  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static Stream_Ntrip* default_instance_;
};
// -------------------------------------------------------------------

class Stream : public ::google::protobuf::Message {
 public:
  Stream();
  virtual ~Stream();

  Stream(const Stream& from);

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream& default_instance();

  enum TypeCase {
    kSerial = 2,
    kTcp = 3,
    kUdp = 4,
    kNtrip = 5,
    TYPE_NOT_SET = 0,
  };

  void Swap(Stream* other);

  // implements Message ----------------------------------------------

  Stream* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Stream_Serial Serial;
  typedef Stream_Tcp Tcp;
  typedef Stream_Udp Udp;
  typedef Stream_Ntrip Ntrip;

  typedef Stream_Format Format;
  static const Format UNKNOWN = Stream_Format_UNKNOWN;
  static const Format NMEA = Stream_Format_NMEA;
  static const Format RTCM_V2 = Stream_Format_RTCM_V2;
  static const Format RTCM_V3 = Stream_Format_RTCM_V3;
  static const Format NOVATEL_TEXT = Stream_Format_NOVATEL_TEXT;
  static const Format NOVATEL_BINARY = Stream_Format_NOVATEL_BINARY;
  static const Format UBLOX_TEXT = Stream_Format_UBLOX_TEXT;
  static const Format UBLOX_BINARY = Stream_Format_UBLOX_BINARY;
  static inline bool Format_IsValid(int value) {
    return Stream_Format_IsValid(value);
  }
  static const Format Format_MIN =
    Stream_Format_Format_MIN;
  static const Format Format_MAX =
    Stream_Format_Format_MAX;
  static const int Format_ARRAYSIZE =
    Stream_Format_Format_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Format_descriptor() {
    return Stream_Format_descriptor();
  }
  static inline const ::std::string& Format_Name(Format value) {
    return Stream_Format_Name(value);
  }
  static inline bool Format_Parse(const ::std::string& name,
      Format* value) {
    return Stream_Format_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .gnss_driver.pb.Stream.Format format = 1;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 1;
  inline ::gnss_driver::pb::Stream_Format format() const;
  inline void set_format(::gnss_driver::pb::Stream_Format value);

  // optional .gnss_driver.pb.Stream.Serial serial = 2;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 2;
  inline const ::gnss_driver::pb::Stream_Serial& serial() const;
  inline ::gnss_driver::pb::Stream_Serial* mutable_serial();
  inline ::gnss_driver::pb::Stream_Serial* release_serial();
  inline void set_allocated_serial(::gnss_driver::pb::Stream_Serial* serial);

  // optional .gnss_driver.pb.Stream.Tcp tcp = 3;
  inline bool has_tcp() const;
  inline void clear_tcp();
  static const int kTcpFieldNumber = 3;
  inline const ::gnss_driver::pb::Stream_Tcp& tcp() const;
  inline ::gnss_driver::pb::Stream_Tcp* mutable_tcp();
  inline ::gnss_driver::pb::Stream_Tcp* release_tcp();
  inline void set_allocated_tcp(::gnss_driver::pb::Stream_Tcp* tcp);

  // optional .gnss_driver.pb.Stream.Udp udp = 4;
  inline bool has_udp() const;
  inline void clear_udp();
  static const int kUdpFieldNumber = 4;
  inline const ::gnss_driver::pb::Stream_Udp& udp() const;
  inline ::gnss_driver::pb::Stream_Udp* mutable_udp();
  inline ::gnss_driver::pb::Stream_Udp* release_udp();
  inline void set_allocated_udp(::gnss_driver::pb::Stream_Udp* udp);

  // optional .gnss_driver.pb.Stream.Ntrip ntrip = 5;
  inline bool has_ntrip() const;
  inline void clear_ntrip();
  static const int kNtripFieldNumber = 5;
  inline const ::gnss_driver::pb::Stream_Ntrip& ntrip() const;
  inline ::gnss_driver::pb::Stream_Ntrip* mutable_ntrip();
  inline ::gnss_driver::pb::Stream_Ntrip* release_ntrip();
  inline void set_allocated_ntrip(::gnss_driver::pb::Stream_Ntrip* ntrip);

  inline TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:gnss_driver.pb.Stream)
 private:
  inline void set_has_format();
  inline void clear_has_format();
  inline void set_has_serial();
  inline void set_has_tcp();
  inline void set_has_udp();
  inline void set_has_ntrip();

  inline bool has_type();
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int format_;
  union TypeUnion {
    ::gnss_driver::pb::Stream_Serial* serial_;
    ::gnss_driver::pb::Stream_Tcp* tcp_;
    ::gnss_driver::pb::Stream_Udp* udp_;
    ::gnss_driver::pb::Stream_Ntrip* ntrip_;
  } type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static Stream* default_instance_;
};
// -------------------------------------------------------------------

class NovatelConfig : public ::google::protobuf::Message {
 public:
  NovatelConfig();
  virtual ~NovatelConfig();

  NovatelConfig(const NovatelConfig& from);

  inline NovatelConfig& operator=(const NovatelConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NovatelConfig& default_instance();

  void Swap(NovatelConfig* other);

  // implements Message ----------------------------------------------

  NovatelConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NovatelConfig& from);
  void MergeFrom(const NovatelConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 imu_orientation = 1 [default = 5];
  inline bool has_imu_orientation() const;
  inline void clear_imu_orientation();
  static const int kImuOrientationFieldNumber = 1;
  inline ::google::protobuf::int32 imu_orientation() const;
  inline void set_imu_orientation(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:gnss_driver.pb.NovatelConfig)
 private:
  inline void set_has_imu_orientation();
  inline void clear_has_imu_orientation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 imu_orientation_;
  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static NovatelConfig* default_instance_;
};
// -------------------------------------------------------------------

class UbloxConfig : public ::google::protobuf::Message {
 public:
  UbloxConfig();
  virtual ~UbloxConfig();

  UbloxConfig(const UbloxConfig& from);

  inline UbloxConfig& operator=(const UbloxConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UbloxConfig& default_instance();

  void Swap(UbloxConfig* other);

  // implements Message ----------------------------------------------

  UbloxConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UbloxConfig& from);
  void MergeFrom(const UbloxConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:gnss_driver.pb.UbloxConfig)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static UbloxConfig* default_instance_;
};
// -------------------------------------------------------------------

class Config : public ::google::protobuf::Message {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  enum DeviceConfigCase {
    kNovatelConfig = 7,
    kUbloxConfig = 8,
    DEVICE_CONFIG_NOT_SET = 0,
  };

  void Swap(Config* other);

  // implements Message ----------------------------------------------

  Config* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Config_RtkSolutionType RtkSolutionType;
  static const RtkSolutionType RTK_RECEIVER_SOLUTION = Config_RtkSolutionType_RTK_RECEIVER_SOLUTION;
  static const RtkSolutionType RTK_SOFTWARE_SOLUTION = Config_RtkSolutionType_RTK_SOFTWARE_SOLUTION;
  static inline bool RtkSolutionType_IsValid(int value) {
    return Config_RtkSolutionType_IsValid(value);
  }
  static const RtkSolutionType RtkSolutionType_MIN =
    Config_RtkSolutionType_RtkSolutionType_MIN;
  static const RtkSolutionType RtkSolutionType_MAX =
    Config_RtkSolutionType_RtkSolutionType_MAX;
  static const int RtkSolutionType_ARRAYSIZE =
    Config_RtkSolutionType_RtkSolutionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RtkSolutionType_descriptor() {
    return Config_RtkSolutionType_descriptor();
  }
  static inline const ::std::string& RtkSolutionType_Name(RtkSolutionType value) {
    return Config_RtkSolutionType_Name(value);
  }
  static inline bool RtkSolutionType_Parse(const ::std::string& name,
      RtkSolutionType* value) {
    return Config_RtkSolutionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .gnss_driver.pb.Stream data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::gnss_driver::pb::Stream& data() const;
  inline ::gnss_driver::pb::Stream* mutable_data();
  inline ::gnss_driver::pb::Stream* release_data();
  inline void set_allocated_data(::gnss_driver::pb::Stream* data);

  // optional .gnss_driver.pb.Stream command = 2;
  inline bool has_command() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 2;
  inline const ::gnss_driver::pb::Stream& command() const;
  inline ::gnss_driver::pb::Stream* mutable_command();
  inline ::gnss_driver::pb::Stream* release_command();
  inline void set_allocated_command(::gnss_driver::pb::Stream* command);

  // optional .gnss_driver.pb.Stream rtk_from = 3;
  inline bool has_rtk_from() const;
  inline void clear_rtk_from();
  static const int kRtkFromFieldNumber = 3;
  inline const ::gnss_driver::pb::Stream& rtk_from() const;
  inline ::gnss_driver::pb::Stream* mutable_rtk_from();
  inline ::gnss_driver::pb::Stream* release_rtk_from();
  inline void set_allocated_rtk_from(::gnss_driver::pb::Stream* rtk_from);

  // optional .gnss_driver.pb.Stream rtk_to = 4;
  inline bool has_rtk_to() const;
  inline void clear_rtk_to();
  static const int kRtkToFieldNumber = 4;
  inline const ::gnss_driver::pb::Stream& rtk_to() const;
  inline ::gnss_driver::pb::Stream* mutable_rtk_to();
  inline ::gnss_driver::pb::Stream* release_rtk_to();
  inline void set_allocated_rtk_to(::gnss_driver::pb::Stream* rtk_to);

  // repeated bytes login_commands = 5;
  inline int login_commands_size() const;
  inline void clear_login_commands();
  static const int kLoginCommandsFieldNumber = 5;
  inline const ::std::string& login_commands(int index) const;
  inline ::std::string* mutable_login_commands(int index);
  inline void set_login_commands(int index, const ::std::string& value);
  inline void set_login_commands(int index, const char* value);
  inline void set_login_commands(int index, const void* value, size_t size);
  inline ::std::string* add_login_commands();
  inline void add_login_commands(const ::std::string& value);
  inline void add_login_commands(const char* value);
  inline void add_login_commands(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& login_commands() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_login_commands();

  // repeated bytes logout_commands = 6;
  inline int logout_commands_size() const;
  inline void clear_logout_commands();
  static const int kLogoutCommandsFieldNumber = 6;
  inline const ::std::string& logout_commands(int index) const;
  inline ::std::string* mutable_logout_commands(int index);
  inline void set_logout_commands(int index, const ::std::string& value);
  inline void set_logout_commands(int index, const char* value);
  inline void set_logout_commands(int index, const void* value, size_t size);
  inline ::std::string* add_logout_commands();
  inline void add_logout_commands(const ::std::string& value);
  inline void add_logout_commands(const char* value);
  inline void add_logout_commands(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& logout_commands() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_logout_commands();

  // optional .gnss_driver.pb.NovatelConfig novatel_config = 7;
  inline bool has_novatel_config() const;
  inline void clear_novatel_config();
  static const int kNovatelConfigFieldNumber = 7;
  inline const ::gnss_driver::pb::NovatelConfig& novatel_config() const;
  inline ::gnss_driver::pb::NovatelConfig* mutable_novatel_config();
  inline ::gnss_driver::pb::NovatelConfig* release_novatel_config();
  inline void set_allocated_novatel_config(::gnss_driver::pb::NovatelConfig* novatel_config);

  // optional .gnss_driver.pb.UbloxConfig ublox_config = 8;
  inline bool has_ublox_config() const;
  inline void clear_ublox_config();
  static const int kUbloxConfigFieldNumber = 8;
  inline const ::gnss_driver::pb::UbloxConfig& ublox_config() const;
  inline ::gnss_driver::pb::UbloxConfig* mutable_ublox_config();
  inline ::gnss_driver::pb::UbloxConfig* release_ublox_config();
  inline void set_allocated_ublox_config(::gnss_driver::pb::UbloxConfig* ublox_config);

  // optional .gnss_driver.pb.Config.RtkSolutionType rtk_solution_type = 9;
  inline bool has_rtk_solution_type() const;
  inline void clear_rtk_solution_type();
  static const int kRtkSolutionTypeFieldNumber = 9;
  inline ::gnss_driver::pb::Config_RtkSolutionType rtk_solution_type() const;
  inline void set_rtk_solution_type(::gnss_driver::pb::Config_RtkSolutionType value);

  inline DeviceConfigCase device_config_case() const;
  // @@protoc_insertion_point(class_scope:gnss_driver.pb.Config)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_command();
  inline void clear_has_command();
  inline void set_has_rtk_from();
  inline void clear_has_rtk_from();
  inline void set_has_rtk_to();
  inline void clear_has_rtk_to();
  inline void set_has_novatel_config();
  inline void set_has_ublox_config();
  inline void set_has_rtk_solution_type();
  inline void clear_has_rtk_solution_type();

  inline bool has_device_config();
  void clear_device_config();
  inline void clear_has_device_config();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::gnss_driver::pb::Stream* data_;
  ::gnss_driver::pb::Stream* command_;
  ::gnss_driver::pb::Stream* rtk_from_;
  ::gnss_driver::pb::Stream* rtk_to_;
  ::google::protobuf::RepeatedPtrField< ::std::string> login_commands_;
  ::google::protobuf::RepeatedPtrField< ::std::string> logout_commands_;
  int rtk_solution_type_;
  union DeviceConfigUnion {
    ::gnss_driver::pb::NovatelConfig* novatel_config_;
    ::gnss_driver::pb::UbloxConfig* ublox_config_;
  } device_config_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_config_2eproto();
  friend void protobuf_AssignDesc_config_2eproto();
  friend void protobuf_ShutdownFile_config_2eproto();

  void InitAsDefaultInstance();
  static Config* default_instance_;
};
// ===================================================================


// ===================================================================

// Stream_Serial

// optional bytes device = 1;
inline bool Stream_Serial::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stream_Serial::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stream_Serial::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stream_Serial::clear_device() {
  if (device_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& Stream_Serial::device() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Stream.Serial.device)
  return *device_;
}
inline void Stream_Serial::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  device_->assign(value);
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Stream.Serial.device)
}
inline void Stream_Serial::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  device_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnss_driver.pb.Stream.Serial.device)
}
inline void Stream_Serial::set_device(const void* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnss_driver.pb.Stream.Serial.device)
}
inline ::std::string* Stream_Serial::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    device_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnss_driver.pb.Stream.Serial.device)
  return device_;
}
inline ::std::string* Stream_Serial::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Stream_Serial::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnss_driver.pb.Stream.Serial.device)
}

// optional int32 baud_rate = 2 [default = 9600];
inline bool Stream_Serial::has_baud_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stream_Serial::set_has_baud_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stream_Serial::clear_has_baud_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stream_Serial::clear_baud_rate() {
  baud_rate_ = 9600;
  clear_has_baud_rate();
}
inline ::google::protobuf::int32 Stream_Serial::baud_rate() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Stream.Serial.baud_rate)
  return baud_rate_;
}
inline void Stream_Serial::set_baud_rate(::google::protobuf::int32 value) {
  set_has_baud_rate();
  baud_rate_ = value;
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Stream.Serial.baud_rate)
}

// -------------------------------------------------------------------

// Stream_Tcp

// optional bytes address = 1;
inline bool Stream_Tcp::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stream_Tcp::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stream_Tcp::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stream_Tcp::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Stream_Tcp::address() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Stream.Tcp.address)
  return *address_;
}
inline void Stream_Tcp::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Stream.Tcp.address)
}
inline void Stream_Tcp::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnss_driver.pb.Stream.Tcp.address)
}
inline void Stream_Tcp::set_address(const void* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnss_driver.pb.Stream.Tcp.address)
}
inline ::std::string* Stream_Tcp::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnss_driver.pb.Stream.Tcp.address)
  return address_;
}
inline ::std::string* Stream_Tcp::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Stream_Tcp::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnss_driver.pb.Stream.Tcp.address)
}

// optional int32 port = 2 [default = 3001];
inline bool Stream_Tcp::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stream_Tcp::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stream_Tcp::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stream_Tcp::clear_port() {
  port_ = 3001;
  clear_has_port();
}
inline ::google::protobuf::int32 Stream_Tcp::port() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Stream.Tcp.port)
  return port_;
}
inline void Stream_Tcp::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Stream.Tcp.port)
}

// -------------------------------------------------------------------

// Stream_Udp

// optional bytes address = 1;
inline bool Stream_Udp::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stream_Udp::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stream_Udp::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stream_Udp::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Stream_Udp::address() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Stream.Udp.address)
  return *address_;
}
inline void Stream_Udp::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Stream.Udp.address)
}
inline void Stream_Udp::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnss_driver.pb.Stream.Udp.address)
}
inline void Stream_Udp::set_address(const void* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnss_driver.pb.Stream.Udp.address)
}
inline ::std::string* Stream_Udp::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnss_driver.pb.Stream.Udp.address)
  return address_;
}
inline ::std::string* Stream_Udp::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Stream_Udp::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnss_driver.pb.Stream.Udp.address)
}

// optional int32 port = 2 [default = 3001];
inline bool Stream_Udp::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stream_Udp::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stream_Udp::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stream_Udp::clear_port() {
  port_ = 3001;
  clear_has_port();
}
inline ::google::protobuf::int32 Stream_Udp::port() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Stream.Udp.port)
  return port_;
}
inline void Stream_Udp::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Stream.Udp.port)
}

// -------------------------------------------------------------------

// Stream_Ntrip

// optional bytes address = 1;
inline bool Stream_Ntrip::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stream_Ntrip::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stream_Ntrip::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stream_Ntrip::clear_address() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Stream_Ntrip::address() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Stream.Ntrip.address)
  return *address_;
}
inline void Stream_Ntrip::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Stream.Ntrip.address)
}
inline void Stream_Ntrip::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnss_driver.pb.Stream.Ntrip.address)
}
inline void Stream_Ntrip::set_address(const void* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnss_driver.pb.Stream.Ntrip.address)
}
inline ::std::string* Stream_Ntrip::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    address_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnss_driver.pb.Stream.Ntrip.address)
  return address_;
}
inline ::std::string* Stream_Ntrip::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Stream_Ntrip::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnss_driver.pb.Stream.Ntrip.address)
}

// optional int32 port = 2 [default = 2101];
inline bool Stream_Ntrip::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stream_Ntrip::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stream_Ntrip::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stream_Ntrip::clear_port() {
  port_ = 2101;
  clear_has_port();
}
inline ::google::protobuf::int32 Stream_Ntrip::port() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Stream.Ntrip.port)
  return port_;
}
inline void Stream_Ntrip::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Stream.Ntrip.port)
}

// optional bytes mount_point = 3;
inline bool Stream_Ntrip::has_mount_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Stream_Ntrip::set_has_mount_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Stream_Ntrip::clear_has_mount_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Stream_Ntrip::clear_mount_point() {
  if (mount_point_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mount_point_->clear();
  }
  clear_has_mount_point();
}
inline const ::std::string& Stream_Ntrip::mount_point() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Stream.Ntrip.mount_point)
  return *mount_point_;
}
inline void Stream_Ntrip::set_mount_point(const ::std::string& value) {
  set_has_mount_point();
  if (mount_point_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mount_point_ = new ::std::string;
  }
  mount_point_->assign(value);
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Stream.Ntrip.mount_point)
}
inline void Stream_Ntrip::set_mount_point(const char* value) {
  set_has_mount_point();
  if (mount_point_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mount_point_ = new ::std::string;
  }
  mount_point_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnss_driver.pb.Stream.Ntrip.mount_point)
}
inline void Stream_Ntrip::set_mount_point(const void* value, size_t size) {
  set_has_mount_point();
  if (mount_point_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mount_point_ = new ::std::string;
  }
  mount_point_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnss_driver.pb.Stream.Ntrip.mount_point)
}
inline ::std::string* Stream_Ntrip::mutable_mount_point() {
  set_has_mount_point();
  if (mount_point_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mount_point_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnss_driver.pb.Stream.Ntrip.mount_point)
  return mount_point_;
}
inline ::std::string* Stream_Ntrip::release_mount_point() {
  clear_has_mount_point();
  if (mount_point_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mount_point_;
    mount_point_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Stream_Ntrip::set_allocated_mount_point(::std::string* mount_point) {
  if (mount_point_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mount_point_;
  }
  if (mount_point) {
    set_has_mount_point();
    mount_point_ = mount_point;
  } else {
    clear_has_mount_point();
    mount_point_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnss_driver.pb.Stream.Ntrip.mount_point)
}

// optional bytes user = 4;
inline bool Stream_Ntrip::has_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Stream_Ntrip::set_has_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Stream_Ntrip::clear_has_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Stream_Ntrip::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& Stream_Ntrip::user() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Stream.Ntrip.user)
  return *user_;
}
inline void Stream_Ntrip::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Stream.Ntrip.user)
}
inline void Stream_Ntrip::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnss_driver.pb.Stream.Ntrip.user)
}
inline void Stream_Ntrip::set_user(const void* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnss_driver.pb.Stream.Ntrip.user)
}
inline ::std::string* Stream_Ntrip::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnss_driver.pb.Stream.Ntrip.user)
  return user_;
}
inline ::std::string* Stream_Ntrip::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Stream_Ntrip::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnss_driver.pb.Stream.Ntrip.user)
}

// optional bytes password = 5;
inline bool Stream_Ntrip::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Stream_Ntrip::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Stream_Ntrip::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Stream_Ntrip::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Stream_Ntrip::password() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Stream.Ntrip.password)
  return *password_;
}
inline void Stream_Ntrip::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Stream.Ntrip.password)
}
inline void Stream_Ntrip::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:gnss_driver.pb.Stream.Ntrip.password)
}
inline void Stream_Ntrip::set_password(const void* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnss_driver.pb.Stream.Ntrip.password)
}
inline ::std::string* Stream_Ntrip::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:gnss_driver.pb.Stream.Ntrip.password)
  return password_;
}
inline ::std::string* Stream_Ntrip::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Stream_Ntrip::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:gnss_driver.pb.Stream.Ntrip.password)
}

// optional uint32 timeout_s = 6 [default = 30];
inline bool Stream_Ntrip::has_timeout_s() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Stream_Ntrip::set_has_timeout_s() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Stream_Ntrip::clear_has_timeout_s() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Stream_Ntrip::clear_timeout_s() {
  timeout_s_ = 30u;
  clear_has_timeout_s();
}
inline ::google::protobuf::uint32 Stream_Ntrip::timeout_s() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Stream.Ntrip.timeout_s)
  return timeout_s_;
}
inline void Stream_Ntrip::set_timeout_s(::google::protobuf::uint32 value) {
  set_has_timeout_s();
  timeout_s_ = value;
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Stream.Ntrip.timeout_s)
}

// -------------------------------------------------------------------

// Stream

// optional .gnss_driver.pb.Stream.Format format = 1;
inline bool Stream::has_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stream::set_has_format() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stream::clear_has_format() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stream::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::gnss_driver::pb::Stream_Format Stream::format() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Stream.format)
  return static_cast< ::gnss_driver::pb::Stream_Format >(format_);
}
inline void Stream::set_format(::gnss_driver::pb::Stream_Format value) {
  assert(::gnss_driver::pb::Stream_Format_IsValid(value));
  set_has_format();
  format_ = value;
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Stream.format)
}

// optional .gnss_driver.pb.Stream.Serial serial = 2;
inline bool Stream::has_serial() const {
  return type_case() == kSerial;
}
inline void Stream::set_has_serial() {
  _oneof_case_[0] = kSerial;
}
inline void Stream::clear_serial() {
  if (has_serial()) {
    delete type_.serial_;
    clear_has_type();
  }
}
inline const ::gnss_driver::pb::Stream_Serial& Stream::serial() const {
  return has_serial() ? *type_.serial_
                      : ::gnss_driver::pb::Stream_Serial::default_instance();
}
inline ::gnss_driver::pb::Stream_Serial* Stream::mutable_serial() {
  if (!has_serial()) {
    clear_type();
    set_has_serial();
    type_.serial_ = new ::gnss_driver::pb::Stream_Serial;
  }
  return type_.serial_;
}
inline ::gnss_driver::pb::Stream_Serial* Stream::release_serial() {
  if (has_serial()) {
    clear_has_type();
    ::gnss_driver::pb::Stream_Serial* temp = type_.serial_;
    type_.serial_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Stream::set_allocated_serial(::gnss_driver::pb::Stream_Serial* serial) {
  clear_type();
  if (serial) {
    set_has_serial();
    type_.serial_ = serial;
  }
}

// optional .gnss_driver.pb.Stream.Tcp tcp = 3;
inline bool Stream::has_tcp() const {
  return type_case() == kTcp;
}
inline void Stream::set_has_tcp() {
  _oneof_case_[0] = kTcp;
}
inline void Stream::clear_tcp() {
  if (has_tcp()) {
    delete type_.tcp_;
    clear_has_type();
  }
}
inline const ::gnss_driver::pb::Stream_Tcp& Stream::tcp() const {
  return has_tcp() ? *type_.tcp_
                      : ::gnss_driver::pb::Stream_Tcp::default_instance();
}
inline ::gnss_driver::pb::Stream_Tcp* Stream::mutable_tcp() {
  if (!has_tcp()) {
    clear_type();
    set_has_tcp();
    type_.tcp_ = new ::gnss_driver::pb::Stream_Tcp;
  }
  return type_.tcp_;
}
inline ::gnss_driver::pb::Stream_Tcp* Stream::release_tcp() {
  if (has_tcp()) {
    clear_has_type();
    ::gnss_driver::pb::Stream_Tcp* temp = type_.tcp_;
    type_.tcp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Stream::set_allocated_tcp(::gnss_driver::pb::Stream_Tcp* tcp) {
  clear_type();
  if (tcp) {
    set_has_tcp();
    type_.tcp_ = tcp;
  }
}

// optional .gnss_driver.pb.Stream.Udp udp = 4;
inline bool Stream::has_udp() const {
  return type_case() == kUdp;
}
inline void Stream::set_has_udp() {
  _oneof_case_[0] = kUdp;
}
inline void Stream::clear_udp() {
  if (has_udp()) {
    delete type_.udp_;
    clear_has_type();
  }
}
inline const ::gnss_driver::pb::Stream_Udp& Stream::udp() const {
  return has_udp() ? *type_.udp_
                      : ::gnss_driver::pb::Stream_Udp::default_instance();
}
inline ::gnss_driver::pb::Stream_Udp* Stream::mutable_udp() {
  if (!has_udp()) {
    clear_type();
    set_has_udp();
    type_.udp_ = new ::gnss_driver::pb::Stream_Udp;
  }
  return type_.udp_;
}
inline ::gnss_driver::pb::Stream_Udp* Stream::release_udp() {
  if (has_udp()) {
    clear_has_type();
    ::gnss_driver::pb::Stream_Udp* temp = type_.udp_;
    type_.udp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Stream::set_allocated_udp(::gnss_driver::pb::Stream_Udp* udp) {
  clear_type();
  if (udp) {
    set_has_udp();
    type_.udp_ = udp;
  }
}

// optional .gnss_driver.pb.Stream.Ntrip ntrip = 5;
inline bool Stream::has_ntrip() const {
  return type_case() == kNtrip;
}
inline void Stream::set_has_ntrip() {
  _oneof_case_[0] = kNtrip;
}
inline void Stream::clear_ntrip() {
  if (has_ntrip()) {
    delete type_.ntrip_;
    clear_has_type();
  }
}
inline const ::gnss_driver::pb::Stream_Ntrip& Stream::ntrip() const {
  return has_ntrip() ? *type_.ntrip_
                      : ::gnss_driver::pb::Stream_Ntrip::default_instance();
}
inline ::gnss_driver::pb::Stream_Ntrip* Stream::mutable_ntrip() {
  if (!has_ntrip()) {
    clear_type();
    set_has_ntrip();
    type_.ntrip_ = new ::gnss_driver::pb::Stream_Ntrip;
  }
  return type_.ntrip_;
}
inline ::gnss_driver::pb::Stream_Ntrip* Stream::release_ntrip() {
  if (has_ntrip()) {
    clear_has_type();
    ::gnss_driver::pb::Stream_Ntrip* temp = type_.ntrip_;
    type_.ntrip_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Stream::set_allocated_ntrip(::gnss_driver::pb::Stream_Ntrip* ntrip) {
  clear_type();
  if (ntrip) {
    set_has_ntrip();
    type_.ntrip_ = ntrip;
  }
}

inline bool Stream::has_type() {
  return type_case() != TYPE_NOT_SET;
}
inline void Stream::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Stream::TypeCase Stream::type_case() const {
  return Stream::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NovatelConfig

// optional int32 imu_orientation = 1 [default = 5];
inline bool NovatelConfig::has_imu_orientation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NovatelConfig::set_has_imu_orientation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NovatelConfig::clear_has_imu_orientation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NovatelConfig::clear_imu_orientation() {
  imu_orientation_ = 5;
  clear_has_imu_orientation();
}
inline ::google::protobuf::int32 NovatelConfig::imu_orientation() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.NovatelConfig.imu_orientation)
  return imu_orientation_;
}
inline void NovatelConfig::set_imu_orientation(::google::protobuf::int32 value) {
  set_has_imu_orientation();
  imu_orientation_ = value;
  // @@protoc_insertion_point(field_set:gnss_driver.pb.NovatelConfig.imu_orientation)
}

// -------------------------------------------------------------------

// UbloxConfig

// -------------------------------------------------------------------

// Config

// optional .gnss_driver.pb.Stream data = 1;
inline bool Config::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Config::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Config::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Config::clear_data() {
  if (data_ != NULL) data_->::gnss_driver::pb::Stream::Clear();
  clear_has_data();
}
inline const ::gnss_driver::pb::Stream& Config::data() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Config.data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::gnss_driver::pb::Stream* Config::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::gnss_driver::pb::Stream;
  // @@protoc_insertion_point(field_mutable:gnss_driver.pb.Config.data)
  return data_;
}
inline ::gnss_driver::pb::Stream* Config::release_data() {
  clear_has_data();
  ::gnss_driver::pb::Stream* temp = data_;
  data_ = NULL;
  return temp;
}
inline void Config::set_allocated_data(::gnss_driver::pb::Stream* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:gnss_driver.pb.Config.data)
}

// optional .gnss_driver.pb.Stream command = 2;
inline bool Config::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Config::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Config::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Config::clear_command() {
  if (command_ != NULL) command_->::gnss_driver::pb::Stream::Clear();
  clear_has_command();
}
inline const ::gnss_driver::pb::Stream& Config::command() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Config.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
inline ::gnss_driver::pb::Stream* Config::mutable_command() {
  set_has_command();
  if (command_ == NULL) command_ = new ::gnss_driver::pb::Stream;
  // @@protoc_insertion_point(field_mutable:gnss_driver.pb.Config.command)
  return command_;
}
inline ::gnss_driver::pb::Stream* Config::release_command() {
  clear_has_command();
  ::gnss_driver::pb::Stream* temp = command_;
  command_ = NULL;
  return temp;
}
inline void Config::set_allocated_command(::gnss_driver::pb::Stream* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:gnss_driver.pb.Config.command)
}

// optional .gnss_driver.pb.Stream rtk_from = 3;
inline bool Config::has_rtk_from() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Config::set_has_rtk_from() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Config::clear_has_rtk_from() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Config::clear_rtk_from() {
  if (rtk_from_ != NULL) rtk_from_->::gnss_driver::pb::Stream::Clear();
  clear_has_rtk_from();
}
inline const ::gnss_driver::pb::Stream& Config::rtk_from() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Config.rtk_from)
  return rtk_from_ != NULL ? *rtk_from_ : *default_instance_->rtk_from_;
}
inline ::gnss_driver::pb::Stream* Config::mutable_rtk_from() {
  set_has_rtk_from();
  if (rtk_from_ == NULL) rtk_from_ = new ::gnss_driver::pb::Stream;
  // @@protoc_insertion_point(field_mutable:gnss_driver.pb.Config.rtk_from)
  return rtk_from_;
}
inline ::gnss_driver::pb::Stream* Config::release_rtk_from() {
  clear_has_rtk_from();
  ::gnss_driver::pb::Stream* temp = rtk_from_;
  rtk_from_ = NULL;
  return temp;
}
inline void Config::set_allocated_rtk_from(::gnss_driver::pb::Stream* rtk_from) {
  delete rtk_from_;
  rtk_from_ = rtk_from;
  if (rtk_from) {
    set_has_rtk_from();
  } else {
    clear_has_rtk_from();
  }
  // @@protoc_insertion_point(field_set_allocated:gnss_driver.pb.Config.rtk_from)
}

// optional .gnss_driver.pb.Stream rtk_to = 4;
inline bool Config::has_rtk_to() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Config::set_has_rtk_to() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Config::clear_has_rtk_to() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Config::clear_rtk_to() {
  if (rtk_to_ != NULL) rtk_to_->::gnss_driver::pb::Stream::Clear();
  clear_has_rtk_to();
}
inline const ::gnss_driver::pb::Stream& Config::rtk_to() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Config.rtk_to)
  return rtk_to_ != NULL ? *rtk_to_ : *default_instance_->rtk_to_;
}
inline ::gnss_driver::pb::Stream* Config::mutable_rtk_to() {
  set_has_rtk_to();
  if (rtk_to_ == NULL) rtk_to_ = new ::gnss_driver::pb::Stream;
  // @@protoc_insertion_point(field_mutable:gnss_driver.pb.Config.rtk_to)
  return rtk_to_;
}
inline ::gnss_driver::pb::Stream* Config::release_rtk_to() {
  clear_has_rtk_to();
  ::gnss_driver::pb::Stream* temp = rtk_to_;
  rtk_to_ = NULL;
  return temp;
}
inline void Config::set_allocated_rtk_to(::gnss_driver::pb::Stream* rtk_to) {
  delete rtk_to_;
  rtk_to_ = rtk_to;
  if (rtk_to) {
    set_has_rtk_to();
  } else {
    clear_has_rtk_to();
  }
  // @@protoc_insertion_point(field_set_allocated:gnss_driver.pb.Config.rtk_to)
}

// repeated bytes login_commands = 5;
inline int Config::login_commands_size() const {
  return login_commands_.size();
}
inline void Config::clear_login_commands() {
  login_commands_.Clear();
}
inline const ::std::string& Config::login_commands(int index) const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Config.login_commands)
  return login_commands_.Get(index);
}
inline ::std::string* Config::mutable_login_commands(int index) {
  // @@protoc_insertion_point(field_mutable:gnss_driver.pb.Config.login_commands)
  return login_commands_.Mutable(index);
}
inline void Config::set_login_commands(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Config.login_commands)
  login_commands_.Mutable(index)->assign(value);
}
inline void Config::set_login_commands(int index, const char* value) {
  login_commands_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:gnss_driver.pb.Config.login_commands)
}
inline void Config::set_login_commands(int index, const void* value, size_t size) {
  login_commands_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnss_driver.pb.Config.login_commands)
}
inline ::std::string* Config::add_login_commands() {
  return login_commands_.Add();
}
inline void Config::add_login_commands(const ::std::string& value) {
  login_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:gnss_driver.pb.Config.login_commands)
}
inline void Config::add_login_commands(const char* value) {
  login_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:gnss_driver.pb.Config.login_commands)
}
inline void Config::add_login_commands(const void* value, size_t size) {
  login_commands_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:gnss_driver.pb.Config.login_commands)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Config::login_commands() const {
  // @@protoc_insertion_point(field_list:gnss_driver.pb.Config.login_commands)
  return login_commands_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Config::mutable_login_commands() {
  // @@protoc_insertion_point(field_mutable_list:gnss_driver.pb.Config.login_commands)
  return &login_commands_;
}

// repeated bytes logout_commands = 6;
inline int Config::logout_commands_size() const {
  return logout_commands_.size();
}
inline void Config::clear_logout_commands() {
  logout_commands_.Clear();
}
inline const ::std::string& Config::logout_commands(int index) const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Config.logout_commands)
  return logout_commands_.Get(index);
}
inline ::std::string* Config::mutable_logout_commands(int index) {
  // @@protoc_insertion_point(field_mutable:gnss_driver.pb.Config.logout_commands)
  return logout_commands_.Mutable(index);
}
inline void Config::set_logout_commands(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Config.logout_commands)
  logout_commands_.Mutable(index)->assign(value);
}
inline void Config::set_logout_commands(int index, const char* value) {
  logout_commands_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:gnss_driver.pb.Config.logout_commands)
}
inline void Config::set_logout_commands(int index, const void* value, size_t size) {
  logout_commands_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gnss_driver.pb.Config.logout_commands)
}
inline ::std::string* Config::add_logout_commands() {
  return logout_commands_.Add();
}
inline void Config::add_logout_commands(const ::std::string& value) {
  logout_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:gnss_driver.pb.Config.logout_commands)
}
inline void Config::add_logout_commands(const char* value) {
  logout_commands_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:gnss_driver.pb.Config.logout_commands)
}
inline void Config::add_logout_commands(const void* value, size_t size) {
  logout_commands_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:gnss_driver.pb.Config.logout_commands)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Config::logout_commands() const {
  // @@protoc_insertion_point(field_list:gnss_driver.pb.Config.logout_commands)
  return logout_commands_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Config::mutable_logout_commands() {
  // @@protoc_insertion_point(field_mutable_list:gnss_driver.pb.Config.logout_commands)
  return &logout_commands_;
}

// optional .gnss_driver.pb.NovatelConfig novatel_config = 7;
inline bool Config::has_novatel_config() const {
  return device_config_case() == kNovatelConfig;
}
inline void Config::set_has_novatel_config() {
  _oneof_case_[0] = kNovatelConfig;
}
inline void Config::clear_novatel_config() {
  if (has_novatel_config()) {
    delete device_config_.novatel_config_;
    clear_has_device_config();
  }
}
inline const ::gnss_driver::pb::NovatelConfig& Config::novatel_config() const {
  return has_novatel_config() ? *device_config_.novatel_config_
                      : ::gnss_driver::pb::NovatelConfig::default_instance();
}
inline ::gnss_driver::pb::NovatelConfig* Config::mutable_novatel_config() {
  if (!has_novatel_config()) {
    clear_device_config();
    set_has_novatel_config();
    device_config_.novatel_config_ = new ::gnss_driver::pb::NovatelConfig;
  }
  return device_config_.novatel_config_;
}
inline ::gnss_driver::pb::NovatelConfig* Config::release_novatel_config() {
  if (has_novatel_config()) {
    clear_has_device_config();
    ::gnss_driver::pb::NovatelConfig* temp = device_config_.novatel_config_;
    device_config_.novatel_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Config::set_allocated_novatel_config(::gnss_driver::pb::NovatelConfig* novatel_config) {
  clear_device_config();
  if (novatel_config) {
    set_has_novatel_config();
    device_config_.novatel_config_ = novatel_config;
  }
}

// optional .gnss_driver.pb.UbloxConfig ublox_config = 8;
inline bool Config::has_ublox_config() const {
  return device_config_case() == kUbloxConfig;
}
inline void Config::set_has_ublox_config() {
  _oneof_case_[0] = kUbloxConfig;
}
inline void Config::clear_ublox_config() {
  if (has_ublox_config()) {
    delete device_config_.ublox_config_;
    clear_has_device_config();
  }
}
inline const ::gnss_driver::pb::UbloxConfig& Config::ublox_config() const {
  return has_ublox_config() ? *device_config_.ublox_config_
                      : ::gnss_driver::pb::UbloxConfig::default_instance();
}
inline ::gnss_driver::pb::UbloxConfig* Config::mutable_ublox_config() {
  if (!has_ublox_config()) {
    clear_device_config();
    set_has_ublox_config();
    device_config_.ublox_config_ = new ::gnss_driver::pb::UbloxConfig;
  }
  return device_config_.ublox_config_;
}
inline ::gnss_driver::pb::UbloxConfig* Config::release_ublox_config() {
  if (has_ublox_config()) {
    clear_has_device_config();
    ::gnss_driver::pb::UbloxConfig* temp = device_config_.ublox_config_;
    device_config_.ublox_config_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Config::set_allocated_ublox_config(::gnss_driver::pb::UbloxConfig* ublox_config) {
  clear_device_config();
  if (ublox_config) {
    set_has_ublox_config();
    device_config_.ublox_config_ = ublox_config;
  }
}

// optional .gnss_driver.pb.Config.RtkSolutionType rtk_solution_type = 9;
inline bool Config::has_rtk_solution_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Config::set_has_rtk_solution_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Config::clear_has_rtk_solution_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Config::clear_rtk_solution_type() {
  rtk_solution_type_ = 1;
  clear_has_rtk_solution_type();
}
inline ::gnss_driver::pb::Config_RtkSolutionType Config::rtk_solution_type() const {
  // @@protoc_insertion_point(field_get:gnss_driver.pb.Config.rtk_solution_type)
  return static_cast< ::gnss_driver::pb::Config_RtkSolutionType >(rtk_solution_type_);
}
inline void Config::set_rtk_solution_type(::gnss_driver::pb::Config_RtkSolutionType value) {
  assert(::gnss_driver::pb::Config_RtkSolutionType_IsValid(value));
  set_has_rtk_solution_type();
  rtk_solution_type_ = value;
  // @@protoc_insertion_point(field_set:gnss_driver.pb.Config.rtk_solution_type)
}

inline bool Config::has_device_config() {
  return device_config_case() != DEVICE_CONFIG_NOT_SET;
}
inline void Config::clear_has_device_config() {
  _oneof_case_[0] = DEVICE_CONFIG_NOT_SET;
}
inline Config::DeviceConfigCase Config::device_config_case() const {
  return Config::DeviceConfigCase(_oneof_case_[0]);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace gnss_driver

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::gnss_driver::pb::Stream_Format> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gnss_driver::pb::Stream_Format>() {
  return ::gnss_driver::pb::Stream_Format_descriptor();
}
template <> struct is_proto_enum< ::gnss_driver::pb::Config_RtkSolutionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gnss_driver::pb::Config_RtkSolutionType>() {
  return ::gnss_driver::pb::Config_RtkSolutionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_config_2eproto__INCLUDED
