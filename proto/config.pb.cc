// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace gnss_driver {
namespace pb {

namespace {

const ::google::protobuf::Descriptor* Stream_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Stream_reflection_ = NULL;
struct StreamOneofInstance {
  const ::gnss_driver::pb::Stream_Serial* serial_;
  const ::gnss_driver::pb::Stream_Tcp* tcp_;
  const ::gnss_driver::pb::Stream_Udp* udp_;
  const ::gnss_driver::pb::Stream_Ntrip* ntrip_;
}* Stream_default_oneof_instance_ = NULL;
const ::google::protobuf::Descriptor* Stream_Serial_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Stream_Serial_reflection_ = NULL;
const ::google::protobuf::Descriptor* Stream_Tcp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Stream_Tcp_reflection_ = NULL;
const ::google::protobuf::Descriptor* Stream_Udp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Stream_Udp_reflection_ = NULL;
const ::google::protobuf::Descriptor* Stream_Ntrip_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Stream_Ntrip_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Stream_Format_descriptor_ = NULL;
const ::google::protobuf::Descriptor* NovatelConfig_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NovatelConfig_reflection_ = NULL;
const ::google::protobuf::Descriptor* UbloxConfig_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UbloxConfig_reflection_ = NULL;
const ::google::protobuf::Descriptor* Config_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Config_reflection_ = NULL;
struct ConfigOneofInstance {
  const ::gnss_driver::pb::NovatelConfig* novatel_config_;
  const ::gnss_driver::pb::UbloxConfig* ublox_config_;
}* Config_default_oneof_instance_ = NULL;
const ::google::protobuf::EnumDescriptor* Config_RtkSolutionType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_config_2eproto() {
  protobuf_AddDesc_config_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "config.proto");
  GOOGLE_CHECK(file != NULL);
  Stream_descriptor_ = file->message_type(0);
  static const int Stream_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream, format_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Stream_default_oneof_instance_, serial_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Stream_default_oneof_instance_, tcp_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Stream_default_oneof_instance_, udp_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Stream_default_oneof_instance_, ntrip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream, type_),
  };
  Stream_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Stream_descriptor_,
      Stream::default_instance_,
      Stream_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream, _unknown_fields_),
      -1,
      Stream_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream, _oneof_case_[0]),
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Stream));
  Stream_Serial_descriptor_ = Stream_descriptor_->nested_type(0);
  static const int Stream_Serial_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Serial, device_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Serial, baud_rate_),
  };
  Stream_Serial_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Stream_Serial_descriptor_,
      Stream_Serial::default_instance_,
      Stream_Serial_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Serial, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Serial, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Stream_Serial));
  Stream_Tcp_descriptor_ = Stream_descriptor_->nested_type(1);
  static const int Stream_Tcp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Tcp, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Tcp, port_),
  };
  Stream_Tcp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Stream_Tcp_descriptor_,
      Stream_Tcp::default_instance_,
      Stream_Tcp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Tcp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Tcp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Stream_Tcp));
  Stream_Udp_descriptor_ = Stream_descriptor_->nested_type(2);
  static const int Stream_Udp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Udp, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Udp, port_),
  };
  Stream_Udp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Stream_Udp_descriptor_,
      Stream_Udp::default_instance_,
      Stream_Udp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Udp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Udp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Stream_Udp));
  Stream_Ntrip_descriptor_ = Stream_descriptor_->nested_type(3);
  static const int Stream_Ntrip_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Ntrip, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Ntrip, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Ntrip, mount_point_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Ntrip, user_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Ntrip, password_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Ntrip, timeout_s_),
  };
  Stream_Ntrip_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Stream_Ntrip_descriptor_,
      Stream_Ntrip::default_instance_,
      Stream_Ntrip_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Ntrip, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Stream_Ntrip, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Stream_Ntrip));
  Stream_Format_descriptor_ = Stream_descriptor_->enum_type(0);
  NovatelConfig_descriptor_ = file->message_type(1);
  static const int NovatelConfig_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NovatelConfig, imu_orientation_),
  };
  NovatelConfig_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NovatelConfig_descriptor_,
      NovatelConfig::default_instance_,
      NovatelConfig_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NovatelConfig, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NovatelConfig, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NovatelConfig));
  UbloxConfig_descriptor_ = file->message_type(2);
  static const int UbloxConfig_offsets_[1] = {
  };
  UbloxConfig_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UbloxConfig_descriptor_,
      UbloxConfig::default_instance_,
      UbloxConfig_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UbloxConfig, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UbloxConfig, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UbloxConfig));
  Config_descriptor_ = file->message_type(3);
  static const int Config_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, rtk_from_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, rtk_to_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, login_commands_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, logout_commands_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Config_default_oneof_instance_, novatel_config_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Config_default_oneof_instance_, ublox_config_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, rtk_solution_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, device_config_),
  };
  Config_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Config_descriptor_,
      Config::default_instance_,
      Config_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, _unknown_fields_),
      -1,
      Config_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, _oneof_case_[0]),
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Config));
  Config_RtkSolutionType_descriptor_ = Config_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_config_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Stream_descriptor_, &Stream::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Stream_Serial_descriptor_, &Stream_Serial::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Stream_Tcp_descriptor_, &Stream_Tcp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Stream_Udp_descriptor_, &Stream_Udp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Stream_Ntrip_descriptor_, &Stream_Ntrip::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NovatelConfig_descriptor_, &NovatelConfig::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UbloxConfig_descriptor_, &UbloxConfig::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Config_descriptor_, &Config::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_config_2eproto() {
  delete Stream::default_instance_;
  delete Stream_default_oneof_instance_;
  delete Stream_reflection_;
  delete Stream_Serial::default_instance_;
  delete Stream_Serial_reflection_;
  delete Stream_Tcp::default_instance_;
  delete Stream_Tcp_reflection_;
  delete Stream_Udp::default_instance_;
  delete Stream_Udp_reflection_;
  delete Stream_Ntrip::default_instance_;
  delete Stream_Ntrip_reflection_;
  delete NovatelConfig::default_instance_;
  delete NovatelConfig_reflection_;
  delete UbloxConfig::default_instance_;
  delete UbloxConfig_reflection_;
  delete Config::default_instance_;
  delete Config_default_oneof_instance_;
  delete Config_reflection_;
}

void protobuf_AddDesc_config_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014config.proto\022\016gnss_driver.pb\"\376\004\n\006Strea"
    "m\022-\n\006format\030\001 \001(\0162\035.gnss_driver.pb.Strea"
    "m.Format\022/\n\006serial\030\002 \001(\0132\035.gnss_driver.p"
    "b.Stream.SerialH\000\022)\n\003tcp\030\003 \001(\0132\032.gnss_dr"
    "iver.pb.Stream.TcpH\000\022)\n\003udp\030\004 \001(\0132\032.gnss"
    "_driver.pb.Stream.UdpH\000\022-\n\005ntrip\030\005 \001(\0132\034"
    ".gnss_driver.pb.Stream.NtripH\000\0321\n\006Serial"
    "\022\016\n\006device\030\001 \001(\014\022\027\n\tbaud_rate\030\002 \001(\005:\004960"
    "0\032*\n\003Tcp\022\017\n\007address\030\001 \001(\014\022\022\n\004port\030\002 \001(\005:"
    "\0043001\032*\n\003Udp\022\017\n\007address\030\001 \001(\014\022\022\n\004port\030\002 "
    "\001(\005:\0043001\032x\n\005Ntrip\022\017\n\007address\030\001 \001(\014\022\022\n\004p"
    "ort\030\002 \001(\005:\0042101\022\023\n\013mount_point\030\003 \001(\014\022\014\n\004"
    "user\030\004 \001(\014\022\020\n\010password\030\005 \001(\014\022\025\n\ttimeout_"
    "s\030\006 \001(\r:\00230\"\201\001\n\006Format\022\013\n\007UNKNOWN\020\000\022\010\n\004N"
    "MEA\020\001\022\013\n\007RTCM_V2\020\002\022\013\n\007RTCM_V3\020\003\022\020\n\014NOVAT"
    "EL_TEXT\020\n\022\022\n\016NOVATEL_BINARY\020\013\022\016\n\nUBLOX_T"
    "EXT\020\024\022\020\n\014UBLOX_BINARY\020\025B\006\n\004type\"+\n\rNovat"
    "elConfig\022\032\n\017imu_orientation\030\001 \001(\005:\0015\"\r\n\013"
    "UbloxConfig\"\345\003\n\006Config\022$\n\004data\030\001 \001(\0132\026.g"
    "nss_driver.pb.Stream\022\'\n\007command\030\002 \001(\0132\026."
    "gnss_driver.pb.Stream\022(\n\010rtk_from\030\003 \001(\0132"
    "\026.gnss_driver.pb.Stream\022&\n\006rtk_to\030\004 \001(\0132"
    "\026.gnss_driver.pb.Stream\022\026\n\016login_command"
    "s\030\005 \003(\014\022\027\n\017logout_commands\030\006 \003(\014\0227\n\016nova"
    "tel_config\030\007 \001(\0132\035.gnss_driver.pb.Novate"
    "lConfigH\000\0223\n\014ublox_config\030\010 \001(\0132\033.gnss_d"
    "river.pb.UbloxConfigH\000\022A\n\021rtk_solution_t"
    "ype\030\t \001(\0162&.gnss_driver.pb.Config.RtkSol"
    "utionType\"G\n\017RtkSolutionType\022\031\n\025RTK_RECE"
    "IVER_SOLUTION\020\001\022\031\n\025RTK_SOFTWARE_SOLUTION"
    "\020\002B\017\n\rdevice_config", 1219);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "config.proto", &protobuf_RegisterTypes);
  Stream::default_instance_ = new Stream();
  Stream_default_oneof_instance_ = new StreamOneofInstance;
  Stream_Serial::default_instance_ = new Stream_Serial();
  Stream_Tcp::default_instance_ = new Stream_Tcp();
  Stream_Udp::default_instance_ = new Stream_Udp();
  Stream_Ntrip::default_instance_ = new Stream_Ntrip();
  NovatelConfig::default_instance_ = new NovatelConfig();
  UbloxConfig::default_instance_ = new UbloxConfig();
  Config::default_instance_ = new Config();
  Config_default_oneof_instance_ = new ConfigOneofInstance;
  Stream::default_instance_->InitAsDefaultInstance();
  Stream_Serial::default_instance_->InitAsDefaultInstance();
  Stream_Tcp::default_instance_->InitAsDefaultInstance();
  Stream_Udp::default_instance_->InitAsDefaultInstance();
  Stream_Ntrip::default_instance_->InitAsDefaultInstance();
  NovatelConfig::default_instance_->InitAsDefaultInstance();
  UbloxConfig::default_instance_->InitAsDefaultInstance();
  Config::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_config_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_config_2eproto {
  StaticDescriptorInitializer_config_2eproto() {
    protobuf_AddDesc_config_2eproto();
  }
} static_descriptor_initializer_config_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* Stream_Format_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Stream_Format_descriptor_;
}
bool Stream_Format_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 10:
    case 11:
    case 20:
    case 21:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Stream_Format Stream::UNKNOWN;
const Stream_Format Stream::NMEA;
const Stream_Format Stream::RTCM_V2;
const Stream_Format Stream::RTCM_V3;
const Stream_Format Stream::NOVATEL_TEXT;
const Stream_Format Stream::NOVATEL_BINARY;
const Stream_Format Stream::UBLOX_TEXT;
const Stream_Format Stream::UBLOX_BINARY;
const Stream_Format Stream::Format_MIN;
const Stream_Format Stream::Format_MAX;
const int Stream::Format_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Stream_Serial::kDeviceFieldNumber;
const int Stream_Serial::kBaudRateFieldNumber;
#endif  // !_MSC_VER

Stream_Serial::Stream_Serial()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gnss_driver.pb.Stream.Serial)
}

void Stream_Serial::InitAsDefaultInstance() {
}

Stream_Serial::Stream_Serial(const Stream_Serial& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gnss_driver.pb.Stream.Serial)
}

void Stream_Serial::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  device_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  baud_rate_ = 9600;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Stream_Serial::~Stream_Serial() {
  // @@protoc_insertion_point(destructor:gnss_driver.pb.Stream.Serial)
  SharedDtor();
}

void Stream_Serial::SharedDtor() {
  if (device_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete device_;
  }
  if (this != default_instance_) {
  }
}

void Stream_Serial::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Stream_Serial::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Stream_Serial_descriptor_;
}

const Stream_Serial& Stream_Serial::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_config_2eproto();
  return *default_instance_;
}

Stream_Serial* Stream_Serial::default_instance_ = NULL;

Stream_Serial* Stream_Serial::New() const {
  return new Stream_Serial;
}

void Stream_Serial::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_device()) {
      if (device_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        device_->clear();
      }
    }
    baud_rate_ = 9600;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Stream_Serial::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gnss_driver.pb.Stream.Serial)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes device = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_device()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_baud_rate;
        break;
      }

      // optional int32 baud_rate = 2 [default = 9600];
      case 2: {
        if (tag == 16) {
         parse_baud_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &baud_rate_)));
          set_has_baud_rate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:gnss_driver.pb.Stream.Serial)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gnss_driver.pb.Stream.Serial)
  return false;
#undef DO_
}

void Stream_Serial::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gnss_driver.pb.Stream.Serial)
  // optional bytes device = 1;
  if (has_device()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->device(), output);
  }

  // optional int32 baud_rate = 2 [default = 9600];
  if (has_baud_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->baud_rate(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:gnss_driver.pb.Stream.Serial)
}

::google::protobuf::uint8* Stream_Serial::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnss_driver.pb.Stream.Serial)
  // optional bytes device = 1;
  if (has_device()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->device(), target);
  }

  // optional int32 baud_rate = 2 [default = 9600];
  if (has_baud_rate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->baud_rate(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnss_driver.pb.Stream.Serial)
  return target;
}

int Stream_Serial::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes device = 1;
    if (has_device()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->device());
    }

    // optional int32 baud_rate = 2 [default = 9600];
    if (has_baud_rate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->baud_rate());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Stream_Serial::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Stream_Serial* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Stream_Serial*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Stream_Serial::MergeFrom(const Stream_Serial& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_device()) {
      set_device(from.device());
    }
    if (from.has_baud_rate()) {
      set_baud_rate(from.baud_rate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Stream_Serial::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Stream_Serial::CopyFrom(const Stream_Serial& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stream_Serial::IsInitialized() const {

  return true;
}

void Stream_Serial::Swap(Stream_Serial* other) {
  if (other != this) {
    std::swap(device_, other->device_);
    std::swap(baud_rate_, other->baud_rate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Stream_Serial::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Stream_Serial_descriptor_;
  metadata.reflection = Stream_Serial_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Stream_Tcp::kAddressFieldNumber;
const int Stream_Tcp::kPortFieldNumber;
#endif  // !_MSC_VER

Stream_Tcp::Stream_Tcp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gnss_driver.pb.Stream.Tcp)
}

void Stream_Tcp::InitAsDefaultInstance() {
}

Stream_Tcp::Stream_Tcp(const Stream_Tcp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gnss_driver.pb.Stream.Tcp)
}

void Stream_Tcp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 3001;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Stream_Tcp::~Stream_Tcp() {
  // @@protoc_insertion_point(destructor:gnss_driver.pb.Stream.Tcp)
  SharedDtor();
}

void Stream_Tcp::SharedDtor() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (this != default_instance_) {
  }
}

void Stream_Tcp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Stream_Tcp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Stream_Tcp_descriptor_;
}

const Stream_Tcp& Stream_Tcp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_config_2eproto();
  return *default_instance_;
}

Stream_Tcp* Stream_Tcp::default_instance_ = NULL;

Stream_Tcp* Stream_Tcp::New() const {
  return new Stream_Tcp;
}

void Stream_Tcp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        address_->clear();
      }
    }
    port_ = 3001;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Stream_Tcp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gnss_driver.pb.Stream.Tcp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes address = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_address()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }

      // optional int32 port = 2 [default = 3001];
      case 2: {
        if (tag == 16) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:gnss_driver.pb.Stream.Tcp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gnss_driver.pb.Stream.Tcp)
  return false;
#undef DO_
}

void Stream_Tcp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gnss_driver.pb.Stream.Tcp)
  // optional bytes address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->address(), output);
  }

  // optional int32 port = 2 [default = 3001];
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->port(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:gnss_driver.pb.Stream.Tcp)
}

::google::protobuf::uint8* Stream_Tcp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnss_driver.pb.Stream.Tcp)
  // optional bytes address = 1;
  if (has_address()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->address(), target);
  }

  // optional int32 port = 2 [default = 3001];
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->port(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnss_driver.pb.Stream.Tcp)
  return target;
}

int Stream_Tcp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->address());
    }

    // optional int32 port = 2 [default = 3001];
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Stream_Tcp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Stream_Tcp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Stream_Tcp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Stream_Tcp::MergeFrom(const Stream_Tcp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Stream_Tcp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Stream_Tcp::CopyFrom(const Stream_Tcp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stream_Tcp::IsInitialized() const {

  return true;
}

void Stream_Tcp::Swap(Stream_Tcp* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Stream_Tcp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Stream_Tcp_descriptor_;
  metadata.reflection = Stream_Tcp_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Stream_Udp::kAddressFieldNumber;
const int Stream_Udp::kPortFieldNumber;
#endif  // !_MSC_VER

Stream_Udp::Stream_Udp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gnss_driver.pb.Stream.Udp)
}

void Stream_Udp::InitAsDefaultInstance() {
}

Stream_Udp::Stream_Udp(const Stream_Udp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gnss_driver.pb.Stream.Udp)
}

void Stream_Udp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 3001;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Stream_Udp::~Stream_Udp() {
  // @@protoc_insertion_point(destructor:gnss_driver.pb.Stream.Udp)
  SharedDtor();
}

void Stream_Udp::SharedDtor() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (this != default_instance_) {
  }
}

void Stream_Udp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Stream_Udp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Stream_Udp_descriptor_;
}

const Stream_Udp& Stream_Udp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_config_2eproto();
  return *default_instance_;
}

Stream_Udp* Stream_Udp::default_instance_ = NULL;

Stream_Udp* Stream_Udp::New() const {
  return new Stream_Udp;
}

void Stream_Udp::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        address_->clear();
      }
    }
    port_ = 3001;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Stream_Udp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gnss_driver.pb.Stream.Udp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes address = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_address()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }

      // optional int32 port = 2 [default = 3001];
      case 2: {
        if (tag == 16) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:gnss_driver.pb.Stream.Udp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gnss_driver.pb.Stream.Udp)
  return false;
#undef DO_
}

void Stream_Udp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gnss_driver.pb.Stream.Udp)
  // optional bytes address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->address(), output);
  }

  // optional int32 port = 2 [default = 3001];
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->port(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:gnss_driver.pb.Stream.Udp)
}

::google::protobuf::uint8* Stream_Udp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnss_driver.pb.Stream.Udp)
  // optional bytes address = 1;
  if (has_address()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->address(), target);
  }

  // optional int32 port = 2 [default = 3001];
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->port(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnss_driver.pb.Stream.Udp)
  return target;
}

int Stream_Udp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->address());
    }

    // optional int32 port = 2 [default = 3001];
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Stream_Udp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Stream_Udp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Stream_Udp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Stream_Udp::MergeFrom(const Stream_Udp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Stream_Udp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Stream_Udp::CopyFrom(const Stream_Udp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stream_Udp::IsInitialized() const {

  return true;
}

void Stream_Udp::Swap(Stream_Udp* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Stream_Udp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Stream_Udp_descriptor_;
  metadata.reflection = Stream_Udp_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Stream_Ntrip::kAddressFieldNumber;
const int Stream_Ntrip::kPortFieldNumber;
const int Stream_Ntrip::kMountPointFieldNumber;
const int Stream_Ntrip::kUserFieldNumber;
const int Stream_Ntrip::kPasswordFieldNumber;
const int Stream_Ntrip::kTimeoutSFieldNumber;
#endif  // !_MSC_VER

Stream_Ntrip::Stream_Ntrip()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gnss_driver.pb.Stream.Ntrip)
}

void Stream_Ntrip::InitAsDefaultInstance() {
}

Stream_Ntrip::Stream_Ntrip(const Stream_Ntrip& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gnss_driver.pb.Stream.Ntrip)
}

void Stream_Ntrip::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 2101;
  mount_point_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timeout_s_ = 30u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Stream_Ntrip::~Stream_Ntrip() {
  // @@protoc_insertion_point(destructor:gnss_driver.pb.Stream.Ntrip)
  SharedDtor();
}

void Stream_Ntrip::SharedDtor() {
  if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete address_;
  }
  if (mount_point_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mount_point_;
  }
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (this != default_instance_) {
  }
}

void Stream_Ntrip::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Stream_Ntrip::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Stream_Ntrip_descriptor_;
}

const Stream_Ntrip& Stream_Ntrip::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_config_2eproto();
  return *default_instance_;
}

Stream_Ntrip* Stream_Ntrip::default_instance_ = NULL;

Stream_Ntrip* Stream_Ntrip::New() const {
  return new Stream_Ntrip;
}

void Stream_Ntrip::Clear() {
  if (_has_bits_[0 / 32] & 63) {
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        address_->clear();
      }
    }
    port_ = 2101;
    if (has_mount_point()) {
      if (mount_point_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        mount_point_->clear();
      }
    }
    if (has_user()) {
      if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_->clear();
      }
    }
    if (has_password()) {
      if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        password_->clear();
      }
    }
    timeout_s_ = 30u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Stream_Ntrip::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gnss_driver.pb.Stream.Ntrip)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes address = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_address()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }

      // optional int32 port = 2 [default = 2101];
      case 2: {
        if (tag == 16) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_mount_point;
        break;
      }

      // optional bytes mount_point = 3;
      case 3: {
        if (tag == 26) {
         parse_mount_point:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_mount_point()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_user;
        break;
      }

      // optional bytes user = 4;
      case 4: {
        if (tag == 34) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_password;
        break;
      }

      // optional bytes password = 5;
      case 5: {
        if (tag == 42) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_password()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_timeout_s;
        break;
      }

      // optional uint32 timeout_s = 6 [default = 30];
      case 6: {
        if (tag == 48) {
         parse_timeout_s:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timeout_s_)));
          set_has_timeout_s();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:gnss_driver.pb.Stream.Ntrip)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gnss_driver.pb.Stream.Ntrip)
  return false;
#undef DO_
}

void Stream_Ntrip::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gnss_driver.pb.Stream.Ntrip)
  // optional bytes address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->address(), output);
  }

  // optional int32 port = 2 [default = 2101];
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->port(), output);
  }

  // optional bytes mount_point = 3;
  if (has_mount_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->mount_point(), output);
  }

  // optional bytes user = 4;
  if (has_user()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->user(), output);
  }

  // optional bytes password = 5;
  if (has_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->password(), output);
  }

  // optional uint32 timeout_s = 6 [default = 30];
  if (has_timeout_s()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->timeout_s(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:gnss_driver.pb.Stream.Ntrip)
}

::google::protobuf::uint8* Stream_Ntrip::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnss_driver.pb.Stream.Ntrip)
  // optional bytes address = 1;
  if (has_address()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->address(), target);
  }

  // optional int32 port = 2 [default = 2101];
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->port(), target);
  }

  // optional bytes mount_point = 3;
  if (has_mount_point()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->mount_point(), target);
  }

  // optional bytes user = 4;
  if (has_user()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->user(), target);
  }

  // optional bytes password = 5;
  if (has_password()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->password(), target);
  }

  // optional uint32 timeout_s = 6 [default = 30];
  if (has_timeout_s()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->timeout_s(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnss_driver.pb.Stream.Ntrip)
  return target;
}

int Stream_Ntrip::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->address());
    }

    // optional int32 port = 2 [default = 2101];
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }

    // optional bytes mount_point = 3;
    if (has_mount_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->mount_point());
    }

    // optional bytes user = 4;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->user());
    }

    // optional bytes password = 5;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->password());
    }

    // optional uint32 timeout_s = 6 [default = 30];
    if (has_timeout_s()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timeout_s());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Stream_Ntrip::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Stream_Ntrip* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Stream_Ntrip*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Stream_Ntrip::MergeFrom(const Stream_Ntrip& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_mount_point()) {
      set_mount_point(from.mount_point());
    }
    if (from.has_user()) {
      set_user(from.user());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
    if (from.has_timeout_s()) {
      set_timeout_s(from.timeout_s());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Stream_Ntrip::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Stream_Ntrip::CopyFrom(const Stream_Ntrip& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stream_Ntrip::IsInitialized() const {

  return true;
}

void Stream_Ntrip::Swap(Stream_Ntrip* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    std::swap(port_, other->port_);
    std::swap(mount_point_, other->mount_point_);
    std::swap(user_, other->user_);
    std::swap(password_, other->password_);
    std::swap(timeout_s_, other->timeout_s_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Stream_Ntrip::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Stream_Ntrip_descriptor_;
  metadata.reflection = Stream_Ntrip_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Stream::kFormatFieldNumber;
const int Stream::kSerialFieldNumber;
const int Stream::kTcpFieldNumber;
const int Stream::kUdpFieldNumber;
const int Stream::kNtripFieldNumber;
#endif  // !_MSC_VER

Stream::Stream()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gnss_driver.pb.Stream)
}

void Stream::InitAsDefaultInstance() {
  Stream_default_oneof_instance_->serial_ = const_cast< ::gnss_driver::pb::Stream_Serial*>(&::gnss_driver::pb::Stream_Serial::default_instance());
  Stream_default_oneof_instance_->tcp_ = const_cast< ::gnss_driver::pb::Stream_Tcp*>(&::gnss_driver::pb::Stream_Tcp::default_instance());
  Stream_default_oneof_instance_->udp_ = const_cast< ::gnss_driver::pb::Stream_Udp*>(&::gnss_driver::pb::Stream_Udp::default_instance());
  Stream_default_oneof_instance_->ntrip_ = const_cast< ::gnss_driver::pb::Stream_Ntrip*>(&::gnss_driver::pb::Stream_Ntrip::default_instance());
}

Stream::Stream(const Stream& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gnss_driver.pb.Stream)
}

void Stream::SharedCtor() {
  _cached_size_ = 0;
  format_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  clear_has_type();
}

Stream::~Stream() {
  // @@protoc_insertion_point(destructor:gnss_driver.pb.Stream)
  SharedDtor();
}

void Stream::SharedDtor() {
  if (has_type()) {
    clear_type();
  }
  if (this != default_instance_) {
  }
}

void Stream::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Stream::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Stream_descriptor_;
}

const Stream& Stream::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_config_2eproto();
  return *default_instance_;
}

Stream* Stream::default_instance_ = NULL;

Stream* Stream::New() const {
  return new Stream;
}

void Stream::clear_type() {
  switch(type_case()) {
    case kSerial: {
      delete type_.serial_;
      break;
    }
    case kTcp: {
      delete type_.tcp_;
      break;
    }
    case kUdp: {
      delete type_.udp_;
      break;
    }
    case kNtrip: {
      delete type_.ntrip_;
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = TYPE_NOT_SET;
}


void Stream::Clear() {
  format_ = 0;
  clear_type();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Stream::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gnss_driver.pb.Stream)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .gnss_driver.pb.Stream.Format format = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::gnss_driver::pb::Stream_Format_IsValid(value)) {
            set_format(static_cast< ::gnss_driver::pb::Stream_Format >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_serial;
        break;
      }

      // optional .gnss_driver.pb.Stream.Serial serial = 2;
      case 2: {
        if (tag == 18) {
         parse_serial:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_serial()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tcp;
        break;
      }

      // optional .gnss_driver.pb.Stream.Tcp tcp = 3;
      case 3: {
        if (tag == 26) {
         parse_tcp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tcp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_udp;
        break;
      }

      // optional .gnss_driver.pb.Stream.Udp udp = 4;
      case 4: {
        if (tag == 34) {
         parse_udp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_udp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_ntrip;
        break;
      }

      // optional .gnss_driver.pb.Stream.Ntrip ntrip = 5;
      case 5: {
        if (tag == 42) {
         parse_ntrip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ntrip()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:gnss_driver.pb.Stream)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gnss_driver.pb.Stream)
  return false;
#undef DO_
}

void Stream::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gnss_driver.pb.Stream)
  // optional .gnss_driver.pb.Stream.Format format = 1;
  if (has_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->format(), output);
  }

  // optional .gnss_driver.pb.Stream.Serial serial = 2;
  if (has_serial()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->serial(), output);
  }

  // optional .gnss_driver.pb.Stream.Tcp tcp = 3;
  if (has_tcp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->tcp(), output);
  }

  // optional .gnss_driver.pb.Stream.Udp udp = 4;
  if (has_udp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->udp(), output);
  }

  // optional .gnss_driver.pb.Stream.Ntrip ntrip = 5;
  if (has_ntrip()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->ntrip(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:gnss_driver.pb.Stream)
}

::google::protobuf::uint8* Stream::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnss_driver.pb.Stream)
  // optional .gnss_driver.pb.Stream.Format format = 1;
  if (has_format()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->format(), target);
  }

  // optional .gnss_driver.pb.Stream.Serial serial = 2;
  if (has_serial()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->serial(), target);
  }

  // optional .gnss_driver.pb.Stream.Tcp tcp = 3;
  if (has_tcp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->tcp(), target);
  }

  // optional .gnss_driver.pb.Stream.Udp udp = 4;
  if (has_udp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->udp(), target);
  }

  // optional .gnss_driver.pb.Stream.Ntrip ntrip = 5;
  if (has_ntrip()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->ntrip(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnss_driver.pb.Stream)
  return target;
}

int Stream::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .gnss_driver.pb.Stream.Format format = 1;
    if (has_format()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->format());
    }

  }
  switch (type_case()) {
    // optional .gnss_driver.pb.Stream.Serial serial = 2;
    case kSerial: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->serial());
      break;
    }
    // optional .gnss_driver.pb.Stream.Tcp tcp = 3;
    case kTcp: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tcp());
      break;
    }
    // optional .gnss_driver.pb.Stream.Udp udp = 4;
    case kUdp: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->udp());
      break;
    }
    // optional .gnss_driver.pb.Stream.Ntrip ntrip = 5;
    case kNtrip: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ntrip());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Stream::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Stream* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Stream*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Stream::MergeFrom(const Stream& from) {
  GOOGLE_CHECK_NE(&from, this);
  switch (from.type_case()) {
    case kSerial: {
      mutable_serial()->::gnss_driver::pb::Stream_Serial::MergeFrom(from.serial());
      break;
    }
    case kTcp: {
      mutable_tcp()->::gnss_driver::pb::Stream_Tcp::MergeFrom(from.tcp());
      break;
    }
    case kUdp: {
      mutable_udp()->::gnss_driver::pb::Stream_Udp::MergeFrom(from.udp());
      break;
    }
    case kNtrip: {
      mutable_ntrip()->::gnss_driver::pb::Stream_Ntrip::MergeFrom(from.ntrip());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_format()) {
      set_format(from.format());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Stream::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Stream::CopyFrom(const Stream& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stream::IsInitialized() const {

  return true;
}

void Stream::Swap(Stream* other) {
  if (other != this) {
    std::swap(format_, other->format_);
    std::swap(type_, other->type_);
    std::swap(_oneof_case_[0], other->_oneof_case_[0]);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Stream::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Stream_descriptor_;
  metadata.reflection = Stream_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NovatelConfig::kImuOrientationFieldNumber;
#endif  // !_MSC_VER

NovatelConfig::NovatelConfig()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gnss_driver.pb.NovatelConfig)
}

void NovatelConfig::InitAsDefaultInstance() {
}

NovatelConfig::NovatelConfig(const NovatelConfig& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gnss_driver.pb.NovatelConfig)
}

void NovatelConfig::SharedCtor() {
  _cached_size_ = 0;
  imu_orientation_ = 5;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NovatelConfig::~NovatelConfig() {
  // @@protoc_insertion_point(destructor:gnss_driver.pb.NovatelConfig)
  SharedDtor();
}

void NovatelConfig::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NovatelConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NovatelConfig::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NovatelConfig_descriptor_;
}

const NovatelConfig& NovatelConfig::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_config_2eproto();
  return *default_instance_;
}

NovatelConfig* NovatelConfig::default_instance_ = NULL;

NovatelConfig* NovatelConfig::New() const {
  return new NovatelConfig;
}

void NovatelConfig::Clear() {
  imu_orientation_ = 5;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NovatelConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gnss_driver.pb.NovatelConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 imu_orientation = 1 [default = 5];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &imu_orientation_)));
          set_has_imu_orientation();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:gnss_driver.pb.NovatelConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gnss_driver.pb.NovatelConfig)
  return false;
#undef DO_
}

void NovatelConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gnss_driver.pb.NovatelConfig)
  // optional int32 imu_orientation = 1 [default = 5];
  if (has_imu_orientation()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->imu_orientation(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:gnss_driver.pb.NovatelConfig)
}

::google::protobuf::uint8* NovatelConfig::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnss_driver.pb.NovatelConfig)
  // optional int32 imu_orientation = 1 [default = 5];
  if (has_imu_orientation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->imu_orientation(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnss_driver.pb.NovatelConfig)
  return target;
}

int NovatelConfig::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 imu_orientation = 1 [default = 5];
    if (has_imu_orientation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->imu_orientation());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NovatelConfig::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NovatelConfig* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NovatelConfig*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NovatelConfig::MergeFrom(const NovatelConfig& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_imu_orientation()) {
      set_imu_orientation(from.imu_orientation());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NovatelConfig::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NovatelConfig::CopyFrom(const NovatelConfig& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NovatelConfig::IsInitialized() const {

  return true;
}

void NovatelConfig::Swap(NovatelConfig* other) {
  if (other != this) {
    std::swap(imu_orientation_, other->imu_orientation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NovatelConfig::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NovatelConfig_descriptor_;
  metadata.reflection = NovatelConfig_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UbloxConfig::UbloxConfig()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gnss_driver.pb.UbloxConfig)
}

void UbloxConfig::InitAsDefaultInstance() {
}

UbloxConfig::UbloxConfig(const UbloxConfig& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gnss_driver.pb.UbloxConfig)
}

void UbloxConfig::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UbloxConfig::~UbloxConfig() {
  // @@protoc_insertion_point(destructor:gnss_driver.pb.UbloxConfig)
  SharedDtor();
}

void UbloxConfig::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UbloxConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UbloxConfig::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UbloxConfig_descriptor_;
}

const UbloxConfig& UbloxConfig::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_config_2eproto();
  return *default_instance_;
}

UbloxConfig* UbloxConfig::default_instance_ = NULL;

UbloxConfig* UbloxConfig::New() const {
  return new UbloxConfig;
}

void UbloxConfig::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UbloxConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gnss_driver.pb.UbloxConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:gnss_driver.pb.UbloxConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gnss_driver.pb.UbloxConfig)
  return false;
#undef DO_
}

void UbloxConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gnss_driver.pb.UbloxConfig)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:gnss_driver.pb.UbloxConfig)
}

::google::protobuf::uint8* UbloxConfig::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnss_driver.pb.UbloxConfig)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnss_driver.pb.UbloxConfig)
  return target;
}

int UbloxConfig::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UbloxConfig::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UbloxConfig* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UbloxConfig*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UbloxConfig::MergeFrom(const UbloxConfig& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UbloxConfig::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UbloxConfig::CopyFrom(const UbloxConfig& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UbloxConfig::IsInitialized() const {

  return true;
}

void UbloxConfig::Swap(UbloxConfig* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UbloxConfig::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UbloxConfig_descriptor_;
  metadata.reflection = UbloxConfig_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Config_RtkSolutionType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Config_RtkSolutionType_descriptor_;
}
bool Config_RtkSolutionType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Config_RtkSolutionType Config::RTK_RECEIVER_SOLUTION;
const Config_RtkSolutionType Config::RTK_SOFTWARE_SOLUTION;
const Config_RtkSolutionType Config::RtkSolutionType_MIN;
const Config_RtkSolutionType Config::RtkSolutionType_MAX;
const int Config::RtkSolutionType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Config::kDataFieldNumber;
const int Config::kCommandFieldNumber;
const int Config::kRtkFromFieldNumber;
const int Config::kRtkToFieldNumber;
const int Config::kLoginCommandsFieldNumber;
const int Config::kLogoutCommandsFieldNumber;
const int Config::kNovatelConfigFieldNumber;
const int Config::kUbloxConfigFieldNumber;
const int Config::kRtkSolutionTypeFieldNumber;
#endif  // !_MSC_VER

Config::Config()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gnss_driver.pb.Config)
}

void Config::InitAsDefaultInstance() {
  data_ = const_cast< ::gnss_driver::pb::Stream*>(&::gnss_driver::pb::Stream::default_instance());
  command_ = const_cast< ::gnss_driver::pb::Stream*>(&::gnss_driver::pb::Stream::default_instance());
  rtk_from_ = const_cast< ::gnss_driver::pb::Stream*>(&::gnss_driver::pb::Stream::default_instance());
  rtk_to_ = const_cast< ::gnss_driver::pb::Stream*>(&::gnss_driver::pb::Stream::default_instance());
  Config_default_oneof_instance_->novatel_config_ = const_cast< ::gnss_driver::pb::NovatelConfig*>(&::gnss_driver::pb::NovatelConfig::default_instance());
  Config_default_oneof_instance_->ublox_config_ = const_cast< ::gnss_driver::pb::UbloxConfig*>(&::gnss_driver::pb::UbloxConfig::default_instance());
}

Config::Config(const Config& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gnss_driver.pb.Config)
}

void Config::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  data_ = NULL;
  command_ = NULL;
  rtk_from_ = NULL;
  rtk_to_ = NULL;
  rtk_solution_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  clear_has_device_config();
}

Config::~Config() {
  // @@protoc_insertion_point(destructor:gnss_driver.pb.Config)
  SharedDtor();
}

void Config::SharedDtor() {
  if (has_device_config()) {
    clear_device_config();
  }
  if (this != default_instance_) {
    delete data_;
    delete command_;
    delete rtk_from_;
    delete rtk_to_;
  }
}

void Config::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Config::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Config_descriptor_;
}

const Config& Config::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_config_2eproto();
  return *default_instance_;
}

Config* Config::default_instance_ = NULL;

Config* Config::New() const {
  return new Config;
}

void Config::clear_device_config() {
  switch(device_config_case()) {
    case kNovatelConfig: {
      delete device_config_.novatel_config_;
      break;
    }
    case kUbloxConfig: {
      delete device_config_.ublox_config_;
      break;
    }
    case DEVICE_CONFIG_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = DEVICE_CONFIG_NOT_SET;
}


void Config::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_data()) {
      if (data_ != NULL) data_->::gnss_driver::pb::Stream::Clear();
    }
    if (has_command()) {
      if (command_ != NULL) command_->::gnss_driver::pb::Stream::Clear();
    }
    if (has_rtk_from()) {
      if (rtk_from_ != NULL) rtk_from_->::gnss_driver::pb::Stream::Clear();
    }
    if (has_rtk_to()) {
      if (rtk_to_ != NULL) rtk_to_->::gnss_driver::pb::Stream::Clear();
    }
  }
  rtk_solution_type_ = 1;
  login_commands_.Clear();
  logout_commands_.Clear();
  clear_device_config();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Config::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gnss_driver.pb.Config)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .gnss_driver.pb.Stream data = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_command;
        break;
      }

      // optional .gnss_driver.pb.Stream command = 2;
      case 2: {
        if (tag == 18) {
         parse_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_rtk_from;
        break;
      }

      // optional .gnss_driver.pb.Stream rtk_from = 3;
      case 3: {
        if (tag == 26) {
         parse_rtk_from:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rtk_from()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_rtk_to;
        break;
      }

      // optional .gnss_driver.pb.Stream rtk_to = 4;
      case 4: {
        if (tag == 34) {
         parse_rtk_to:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rtk_to()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_login_commands;
        break;
      }

      // repeated bytes login_commands = 5;
      case 5: {
        if (tag == 42) {
         parse_login_commands:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_login_commands()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_login_commands;
        if (input->ExpectTag(50)) goto parse_logout_commands;
        break;
      }

      // repeated bytes logout_commands = 6;
      case 6: {
        if (tag == 50) {
         parse_logout_commands:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_logout_commands()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_logout_commands;
        if (input->ExpectTag(58)) goto parse_novatel_config;
        break;
      }

      // optional .gnss_driver.pb.NovatelConfig novatel_config = 7;
      case 7: {
        if (tag == 58) {
         parse_novatel_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_novatel_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_ublox_config;
        break;
      }

      // optional .gnss_driver.pb.UbloxConfig ublox_config = 8;
      case 8: {
        if (tag == 66) {
         parse_ublox_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ublox_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_rtk_solution_type;
        break;
      }

      // optional .gnss_driver.pb.Config.RtkSolutionType rtk_solution_type = 9;
      case 9: {
        if (tag == 72) {
         parse_rtk_solution_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::gnss_driver::pb::Config_RtkSolutionType_IsValid(value)) {
            set_rtk_solution_type(static_cast< ::gnss_driver::pb::Config_RtkSolutionType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:gnss_driver.pb.Config)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gnss_driver.pb.Config)
  return false;
#undef DO_
}

void Config::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gnss_driver.pb.Config)
  // optional .gnss_driver.pb.Stream data = 1;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->data(), output);
  }

  // optional .gnss_driver.pb.Stream command = 2;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->command(), output);
  }

  // optional .gnss_driver.pb.Stream rtk_from = 3;
  if (has_rtk_from()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->rtk_from(), output);
  }

  // optional .gnss_driver.pb.Stream rtk_to = 4;
  if (has_rtk_to()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->rtk_to(), output);
  }

  // repeated bytes login_commands = 5;
  for (int i = 0; i < this->login_commands_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->login_commands(i), output);
  }

  // repeated bytes logout_commands = 6;
  for (int i = 0; i < this->logout_commands_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->logout_commands(i), output);
  }

  // optional .gnss_driver.pb.NovatelConfig novatel_config = 7;
  if (has_novatel_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->novatel_config(), output);
  }

  // optional .gnss_driver.pb.UbloxConfig ublox_config = 8;
  if (has_ublox_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->ublox_config(), output);
  }

  // optional .gnss_driver.pb.Config.RtkSolutionType rtk_solution_type = 9;
  if (has_rtk_solution_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->rtk_solution_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:gnss_driver.pb.Config)
}

::google::protobuf::uint8* Config::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gnss_driver.pb.Config)
  // optional .gnss_driver.pb.Stream data = 1;
  if (has_data()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->data(), target);
  }

  // optional .gnss_driver.pb.Stream command = 2;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->command(), target);
  }

  // optional .gnss_driver.pb.Stream rtk_from = 3;
  if (has_rtk_from()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->rtk_from(), target);
  }

  // optional .gnss_driver.pb.Stream rtk_to = 4;
  if (has_rtk_to()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->rtk_to(), target);
  }

  // repeated bytes login_commands = 5;
  for (int i = 0; i < this->login_commands_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(5, this->login_commands(i), target);
  }

  // repeated bytes logout_commands = 6;
  for (int i = 0; i < this->logout_commands_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(6, this->logout_commands(i), target);
  }

  // optional .gnss_driver.pb.NovatelConfig novatel_config = 7;
  if (has_novatel_config()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->novatel_config(), target);
  }

  // optional .gnss_driver.pb.UbloxConfig ublox_config = 8;
  if (has_ublox_config()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->ublox_config(), target);
  }

  // optional .gnss_driver.pb.Config.RtkSolutionType rtk_solution_type = 9;
  if (has_rtk_solution_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->rtk_solution_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:gnss_driver.pb.Config)
  return target;
}

int Config::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .gnss_driver.pb.Stream data = 1;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->data());
    }

    // optional .gnss_driver.pb.Stream command = 2;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->command());
    }

    // optional .gnss_driver.pb.Stream rtk_from = 3;
    if (has_rtk_from()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rtk_from());
    }

    // optional .gnss_driver.pb.Stream rtk_to = 4;
    if (has_rtk_to()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rtk_to());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .gnss_driver.pb.Config.RtkSolutionType rtk_solution_type = 9;
    if (has_rtk_solution_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->rtk_solution_type());
    }

  }
  // repeated bytes login_commands = 5;
  total_size += 1 * this->login_commands_size();
  for (int i = 0; i < this->login_commands_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->login_commands(i));
  }

  // repeated bytes logout_commands = 6;
  total_size += 1 * this->logout_commands_size();
  for (int i = 0; i < this->logout_commands_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->logout_commands(i));
  }

  switch (device_config_case()) {
    // optional .gnss_driver.pb.NovatelConfig novatel_config = 7;
    case kNovatelConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->novatel_config());
      break;
    }
    // optional .gnss_driver.pb.UbloxConfig ublox_config = 8;
    case kUbloxConfig: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ublox_config());
      break;
    }
    case DEVICE_CONFIG_NOT_SET: {
      break;
    }
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Config::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Config* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Config*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Config::MergeFrom(const Config& from) {
  GOOGLE_CHECK_NE(&from, this);
  login_commands_.MergeFrom(from.login_commands_);
  logout_commands_.MergeFrom(from.logout_commands_);
  switch (from.device_config_case()) {
    case kNovatelConfig: {
      mutable_novatel_config()->::gnss_driver::pb::NovatelConfig::MergeFrom(from.novatel_config());
      break;
    }
    case kUbloxConfig: {
      mutable_ublox_config()->::gnss_driver::pb::UbloxConfig::MergeFrom(from.ublox_config());
      break;
    }
    case DEVICE_CONFIG_NOT_SET: {
      break;
    }
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      mutable_data()->::gnss_driver::pb::Stream::MergeFrom(from.data());
    }
    if (from.has_command()) {
      mutable_command()->::gnss_driver::pb::Stream::MergeFrom(from.command());
    }
    if (from.has_rtk_from()) {
      mutable_rtk_from()->::gnss_driver::pb::Stream::MergeFrom(from.rtk_from());
    }
    if (from.has_rtk_to()) {
      mutable_rtk_to()->::gnss_driver::pb::Stream::MergeFrom(from.rtk_to());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_rtk_solution_type()) {
      set_rtk_solution_type(from.rtk_solution_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Config::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Config::CopyFrom(const Config& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Config::IsInitialized() const {

  return true;
}

void Config::Swap(Config* other) {
  if (other != this) {
    std::swap(data_, other->data_);
    std::swap(command_, other->command_);
    std::swap(rtk_from_, other->rtk_from_);
    std::swap(rtk_to_, other->rtk_to_);
    login_commands_.Swap(&other->login_commands_);
    logout_commands_.Swap(&other->logout_commands_);
    std::swap(rtk_solution_type_, other->rtk_solution_type_);
    std::swap(device_config_, other->device_config_);
    std::swap(_oneof_case_[0], other->_oneof_case_[0]);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Config::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Config_descriptor_;
  metadata.reflection = Config_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace gnss_driver

// @@protoc_insertion_point(global_scope)
